#!/usr/bin/env ruby

require "open-uri"
require "nokogiri"

doc = Nokogiri::HTML(open("http://dicom.nema.org/medical/dicom/current/source/docbook/part06/part06.xml"))

# tag: (0000,FFFF)
def tag_hash_from_row(row)
  cells = row.xpath("td")
  {
    tag:     cells[0].content.strip.gsub(/\u200b/, ""),
    name:    cells[1].content.strip.gsub(/\u200b/, ""),
    keyword: cells[2].content.strip.gsub(/\u200b/, ""),
    vr:      cells[3].content.strip.gsub(/\u200b/, "").gsub(" or ", "/"),
    vm:      cells[4].content.strip.gsub(/\u200b/, ""),
    other:   cells[5].content.strip.gsub(/\u200b/, "")
  }
end

dicom_file_meta_elements = doc.xpath("//table[@label='7-1']/tbody/tr").map do |row|
  tag_hash_from_row(row)
end

dicom_directory_structuring_elements = doc.xpath("//table[@label='8-1']/tbody/tr").map do |row|
  tag_hash_from_row(row)
end

dicom_data_elements = doc.xpath("//table[@label='6-1']/tbody/tr").map do |row|
  tag_hash_from_row(row)
end

def uid_hash_from_row(row)
  cells = row.xpath("td")
  {
    value: cells[0].content.strip.gsub(/\u200b/, ""),
    name: cells[1].content.strip.gsub(/\u200b/, ""),
    type: cells[2].content.strip.gsub(/\u200b/, ""),
    part: cells[3].content.strip.gsub(/\u200b/, "")
  }
end

doc2 = Nokogiri::HTML(open("http://dicom.nema.org/medical/dicom/current/source/docbook/part07/part07.xml"))

command_fields = doc2.xpath("//table[@label='E.1-1']/tbody/tr").map do |row|
  tag_hash_from_row(row)
end

uids = doc.xpath("//table[@label='A-1']/tbody/tr").map do |row|
  uid_hash_from_row(row)
end

elements = command_fields + dicom_file_meta_elements + dicom_directory_structuring_elements + dicom_data_elements
good_elements = elements.select do |row|
  # Skip blank retired entries
  !(row[:other] =~ /RET/) || (row[:vr] != "" && row[:keyword] != "")
end

MULTI_VR = [
  "OB/OW",
  "US/SS",
  "US/SS/OW",
  "US/OW"
]

MULTI_VR_TO_SINGLE_VR = {
  "OB/OW" => "ox",
  "US/SS" => "xs",
  "US/SS/OW" => "xw",
  "US/OW" => "uw"
}

VR_MAP = {"1-n or 1" => "1-n"}

lines = good_elements.map do |row|
  vr = row[:vr] == "See Note" ? "UN" : row[:vr]
  # vr = "xx" if vr.size > 2

  match = row[:tag].match(/\(([\hxX]{4}),([\hxX]{4})\)/)
  raise "Invalid tag #{row[:tag]}" unless match

  group = match[1]
  element = match[2]

  name = row[:keyword]

  vm = VR_MAP[row[:vm]] ? VR_MAP[row[:vm]] : row[:vm]

  vm_split = vm.split("-")
  if vm_split.count == 1
    vm_args = [vm_split[0], vm_split[0], false]
  else
    if vm_split[1][-1] == "n"
      multiple = vm_split[1][0...-1]
      multiple = 1 if multiple == ""

      vm_args = [vm_split[0], multiple, true]
    else
      vm_args = [vm_split[0], vm_split[1], false]
    end
  end

  {
    group: group,
    element: element,
    group_value: group.gsub(/x/, "0"),
    group_mask: group.gsub(/[^x]/, "F").gsub(/x/, "0"),
    element_value: element.gsub(/x/, "0"),
    element_mask: element.gsub(/[^x]/, "F").gsub(/x/, "0"),
    vr: vr,
    name: name,
    vm: vm,
    vm_args: vm_args,
    other: row[:other]
  }
end

# TODO: Add gdcm license
# NOTE: This is pointing to the master branch instead of a specific commit, so the content could change.
# This allows easy updating
private_doc = Nokogiri::HTML(open("https://raw.githubusercontent.com/malaterre/GDCM/master/Source/DataDictionary/privatedicts.xml"))

PRIVATE_VR_TO_SINGLE_VR = {"OB_OW" => "ox"}

all_private_entries = private_doc.xpath("//dict/entry").map do |entry|
  {
    owner: entry["owner"],
    group: entry["group"],
    element: entry["element"],
    vr: PRIVATE_VR_TO_SINGLE_VR[entry["vr"]] || entry["vr"],
    vm: entry["vm"],
    name: entry["name"].strip =~ /\A\?*\z/ ? "Unknown" : entry["name"]
  }
end.select do |entry|
  entry[:element] =~ /xx[0-9a-fA-F]{2}/ && !entry[:owner].strip.empty?
end.sort do |entry1, entry2|
  "#{entry1[:owner]} #{entry1[:group]} #{entry1[:element]}" <=> "#{entry2[:owner]} #{entry2[:group]} #{entry2[:element]}"
end

unless lines.map {|line| line[:name]}.uniq.count == lines.count
  raise "Error!  Conflicting names found"
end

unless lines.map {|line| "#{line[:group]}#{line[:element]}"}.uniq.count == lines.count
  raise "Error!  Conflicting tags found"
end

File.open(File.expand_path("../../test/dictionary.txt", __FILE__), "w") do |f|
  f.puts "# Generated by bin/dictionary_build at #{Time.now}"

  # Public elements
  lines.each do |line|
    f.puts "public (#{line[:group]},#{line[:element]}) #{line[:vr]} #{line[:name]} #{line[:vm]}"
  end

  # Include retired GroupLength generic element (xxxx,0000)
  f.puts "public (xxxx,0000) UL GroupLength 1"

  all_private_entries.each do |entry|
    f.puts "private \"#{entry[:owner]}\" (#{entry[:group]},#{entry[:element]}) #{entry[:vr]} #{entry[:vm]} \"#{entry[:name]}\""
  end
end

File.open(File.expand_path("../../include/vega/dictionary_data.h", __FILE__), "w") do |f|
  f.puts "// Generated with bin/dictionary_build at #{Time.now}"
  f.puts ""
  f.puts "#pragma once"
  f.puts ""
  f.puts "#include <vector>"
  f.puts "#include <memory>"
  f.puts "#include <type_traits>"
  f.puts ""
  f.puts "#include \"vega/tag.h\""
  f.puts "#include \"vega/tag_mask.h\""
  f.puts "#include \"vega/vr.h\""
  f.puts "#include \"vega/vm.h\""
  f.puts "#include \"vega/manipulator.h\""
  f.puts ""
  f.puts "namespace vega {"
  f.puts "  namespace dictionary {"
  f.puts "    template <typename T, typename = int>"
  f.puts "    struct HasTag : std::false_type {};"
  f.puts ""
  f.puts "    template <typename T>"
  f.puts "    struct HasTag <T, decltype((void) T::tag, 0)> : std::true_type {};"
  f.puts ""

  lines.each do |line|
    vrs = line[:vr].split("/")

    vrs.each do |vr|
      if vrs.size == 1
        f.puts "    struct #{line[:name]} {"
      else
        f.puts "    struct #{line[:name]}_#{vr} {"
      end

      # Only include Tag if unique tag
      f.puts "      static constexpr const char name[] = \"#{line[:name]}\";"
      if line[:group_mask] == "FFFF" && line[:element_mask] == "FFFF"
        f.puts "      static constexpr const Tag tag {0x#{line[:group]}, 0x#{line[:element]}};"
      end
      f.puts "      static constexpr const TagMask tag_mask {0x#{line[:group_value]}, 0x#{line[:group_mask]}, 0x#{line[:element_value]}, 0x#{line[:element_mask]}};"
      f.puts "      static constexpr const VR vr {'#{vr[0]}', '#{vr[1]}'};"
      f.puts "      static constexpr const VM vm {#{line[:vm_args].map(&:to_s).join(', ')}};"
      # No manipulator exists yet for sequences
      f.puts "      typedef #{vr == "SQ" ? "void" : "#{vr}_Manipulator"} manipulator_type;"
      f.puts "    };"
      f.puts ""
    end
  end

  f.puts "    struct GroupLength {"
  f.puts "      static constexpr const char name[] = \"GroupLength\";"
  f.puts "      static constexpr const TagMask tag_mask {0x0000, 0x0000, 0x0000, 0xFFFF};"
  f.puts "      static constexpr const VR vr {'L', 'O'};"
  f.puts "      static constexpr const VM vm {1, 1, false};"
  f.puts "      typedef UL_Manipulator manipulator_type;"
  f.puts "    };"
  f.puts ""

  f.puts "    struct PrivateElement {"
  f.puts "      static constexpr const char name[] = \"PrivateElement\";"
  f.puts "      static constexpr const TagMask tag_mask {0x0001, 0x0001, 0x0000, 0x0000};"
  f.puts "      static constexpr const VR vr {'L', 'O'};"
  f.puts "      static constexpr const VM vm {1, 1, true};"
  f.puts "      typedef LO_Manipulator manipulator_type;"
  f.puts "    };"
  f.puts ""

  f.puts "  }"
  f.puts "}"
end

File.open(File.expand_path("../../src/vega/dictionary_data.cpp", __FILE__), "w") do |f|
  f.puts "// Generated with bin/dictionary_build at #{Time.now}"
  f.puts ""
  f.puts "#include \"vega/dictionary_data.h\""
  f.puts ""
  f.puts "namespace vega {"
  f.puts "  namespace dictionary {"
  f.puts ""

  lines.each do |line|
    vrs = line[:vr].split("/")

    vrs.each do |vr|
      name = if vrs.size == 1
               line[:name].to_s
             else
               "#{line[:name]}_#{vr}"
             end

      # Only include Tag if unique tag
      f.puts "    constexpr const char #{name}::name[];"
      if line[:group_mask] == "FFFF" && line[:element_mask] == "FFFF"
        f.puts "    constexpr const Tag #{name}::tag;"
      end
      f.puts "    constexpr const TagMask #{name}::tag_mask;"
      f.puts "    constexpr const VR #{name}::vr;"
      f.puts "    constexpr const VM #{name}::vm;"
      f.puts ""
    end
  end

  f.puts "    constexpr const char GroupLength::name[];"
  f.puts "    constexpr const TagMask GroupLength::tag_mask;"
  f.puts "    constexpr const VR GroupLength::vr;"
  f.puts "    constexpr const VM GroupLength::vm;"
  f.puts ""

  f.puts "    constexpr const char PrivateElement::name[];"
  f.puts "    constexpr const TagMask PrivateElement::tag_mask;"
  f.puts "    constexpr const VR PrivateElement::vr;"
  f.puts "    constexpr const VM PrivateElement::vm;"
  f.puts ""

  f.puts "  }"
  f.puts "}"
end
